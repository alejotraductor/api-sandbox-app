"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var spy_adapter_factory_1 = require("./spy-adapter-factory");
var Mockery = (function () {
    function Mockery() {
    }
    Object.defineProperty(Mockery, "noop", {
        get: function () {
            return this.spyAdapter.getSpy('any');
        },
        enumerable: true,
        configurable: true
    });
    Mockery.all = function () {
        var _this = this;
        var handler = {
            get: function (target, prop) {
                if (!target[prop]) {
                    target[prop] = _this.spyAdapter.getSpy('any');
                }
                return target[prop];
            }
        };
        return new Proxy({}, handler);
    };
    Mockery.configure = function (spyAdapter) {
        this.spyAdapter = typeof spyAdapter === 'string' ? spy_adapter_factory_1.SpyAdapterFactory.get(spyAdapter) : spyAdapter;
    };
    Mockery.extend = function (object) {
        return this.withGenerator(object);
    };
    Mockery.from = function (object) {
        return object;
    };
    Mockery.of = function (stubs) {
        if (stubs === void 0) { stubs = {}; }
        if (Array.isArray(stubs)) {
            return stubs;
        }
        return this.extend({}).with(stubs);
    };
    Mockery.staticMethod = function (object, key, stub) {
        this.spyAdapter.spyAndCallFake(object, key, stub);
    };
    Mockery.spyOnTheStubbedFunctions = function (object, key) {
        var _this = this;
        if (typeof object[key] === typeof Function) {
            this.spyAdapter.spyAndCallThrough(object, key);
        }
        else if (typeof object[key] === typeof {} && object[key] !== null) {
            Object.keys(object[key]).forEach(function (subKey) {
                _this.spyOnTheStubbedFunctions(object[key], subKey);
            });
        }
    };
    Mockery.withGenerator = function (object) {
        var _this = this;
        return {
            with: function (stubs) {
                if (stubs === void 0) { stubs = {}; }
                var currentKey = '';
                try {
                    Object.keys(stubs).forEach(function (key) {
                        currentKey = key;
                        _this.spyOnTheStubbedFunctions(stubs, key);
                    });
                }
                catch (e) {
                    if (e instanceof RangeError) {
                        throw new Error("Return value of " + currentKey + " has a circular reference.\nConsider using Mock.from instead.");
                    }
                    throw e;
                }
                return Object.assign(object, stubs);
            }
        };
    };
    Mockery.spyAdapter = spy_adapter_factory_1.SpyAdapterFactory.get('noop');
    return Mockery;
}());
exports.Mockery = Mockery;
//# sourceMappingURL=mockery.js.map